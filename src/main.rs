use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use dirs::home_dir;
use glob::Pattern;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{self, create_dir_all, File};
use std::io::Write;
use std::path::{Path, PathBuf};
use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};
use thiserror::Error;

// Include the generated file with embedded content
// This is generated by build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_files.rs"));

// Custom error types
#[derive(Error, Debug)]
enum DotfilesError {
    #[error("Repository not found: {0}")]
    RepoNotFound(String),
    
    #[error("Distribution file not found: {0}")]
    DistributionNotFound(String),
    
    #[error("Failed to parse distribution file: {0}")]
    DistributionParseError(String),
    
    #[error("File not found: {0}")]
    FileNotFound(String),
    
    #[error("Invalid command format: {0}")]
    InvalidCommand(String),
    
    #[error("File not found in archive: {0}")]
    ArchiveFileNotFound(String),
    
    #[error("Failed to read file from archive: {0}")]
    ArchiveReadError(String),
}

// Status symbols
const CHECK_MARK: &str = "✓";
const CROSS_MARK: &str = "✗";
const WARNING_MARK: &str = "⚠";
const INFO_MARK: &str = "ℹ";
const ARROW_MARK: &str = "→";

// The file embedding is handled by build.rs and the embedded_files.rs file

// Command line arguments
#[derive(Parser)]
#[clap(
    name = "dotfiles-rs",
    about = "Manages dotfiles between system configuration directories and git repository",
    version = env!("CARGO_PKG_VERSION"),
    after_help = "Build identity: ",
    after_long_help = concat!("Build identity: ", env!("BUILD_IDENTITY", "unknown"), "\nNewest file: ", env!("NEWEST_FILE", "unknown"))
)]
struct Cli {
    /// Enable verbose output with detailed information
    #[clap(short, long, global = true)]
    verbose: bool,

    /// Show all files including identical ones when checking status
    #[clap(short, long, global = true)]
    all: bool,

    #[clap(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// Sync files from $HOME/.config to repository
    Sync,
    
    /// Show status of files in distribution.toml
    Status,
    
    /// Install files from repository to $HOME/.config
    Install,
    
    /// Add a file to distribution.toml and copy to repo
    Add {
        /// The tool name (directory under .config)
        tool: String,
        
        /// The file name to add
        file: String,
    },
    
    /// Remove a file from distribution.toml
    Remove {
        /// The tool name (directory under .config)
        tool: String,
        
        /// The file name to remove
        file: String,
    },
    
    /// Check that distribution.toml exists and has valid syntax
    Precheck,
    
    /// Show usage information
    Usage,
    
    /// Show version and build information
    Version,
}

// Output formatter helper
struct Formatter {
    stdout: StandardStream,
    verbose: bool,
}

impl Formatter {
    fn new(verbose: bool) -> Self {
        Self {
            stdout: StandardStream::stdout(ColorChoice::Auto),
            verbose,
        }
    }
    
    fn print(&mut self, message: &str, color: Option<Color>, bold_italic: bool) -> Result<()> {
        let mut color_spec = ColorSpec::new();
        if let Some(c) = color {
            color_spec.set_fg(Some(c));
        }
        color_spec.set_bold(bold_italic);
        color_spec.set_italic(bold_italic);
        
        self.stdout.set_color(&color_spec)?;
        write!(self.stdout, "{}", message)?;
        self.stdout.reset()?;
        Ok(())
    }
    
    
    fn success(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Format the message with the part before the colon in bold italics
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Green), true)?; // Make the status part green and bold
            self.print(content, None, false)?;
        } else {
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn warning(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", WARNING_MARK), Some(Color::Yellow), false)?;
        
        // Special case for "Not installed:" messages
        if message.starts_with("Not installed:") {
            // Redirect to not_installed formatter for consistent styling
            return self.not_installed(message);
        }
        
        // Special case for "File not found:" messages
        if message.starts_with("File not found:") || message.starts_with("Local file not found:") {
            if let Some(idx) = message.find(": ") {
                let (status, path) = message.split_at(idx + 2);
                self.print(status, Some(Color::Yellow), true)?; // Make the status part yellow and bold
                self.print(path, None, false)?;
            } else {
                self.print(message, None, false)?;
            }
        } else {
            // Default handling for other warnings with the part before the colon in bold
            if let Some(idx) = message.find(": ") {
                let (status, content) = message.split_at(idx + 2);
                self.print(status, Some(Color::Yellow), true)?; // Make the status part yellow and bold
                self.print(content, None, false)?;
            } else {
                self.print(message, None, false)?;
            }
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn error(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", CROSS_MARK), Some(Color::Red), false)?;
        
        // Format error messages with status text in red and bold
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Red), true)?; // Make the status part red and bold
            self.print(content, None, false)?;
        } else {
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn info(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", INFO_MARK), Some(Color::Blue), false)?;
        
        // Process tool names differently
        if message.starts_with("Processing tool:") {
            if let Some(idx) = message.find(": ") {
                let (status, tool) = message.split_at(idx + 2);
                self.print(status, Some(Color::Blue), true)?; // Make the status part blue and bold
                self.print(tool, Some(Color::White), true)?;  // Make the tool name white and bold
            } else {
                self.print(message, None, false)?;
            }
        } else {
            // Format other info messages with status text in blue and bold
            if let Some(idx) = message.find(": ") {
                let (status, content) = message.split_at(idx + 2);
                self.print(status, Some(Color::Blue), true)?; // Make the status part blue and bold
                self.print(content, None, false)?;
            } else {
                self.print(message, None, false)?;
            }
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn modified(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", ARROW_MARK), Some(Color::Magenta), false)?;
        
        // Format modified messages with status text in magenta and bold
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Magenta), true)?; // Make the status part magenta and bold
            self.print(content, None, false)?;
        } else {
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn identical(&mut self, message: &str) -> Result<()> {
        // Use green for icon, and make the text blue for better visibility
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Identical: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Blue), true)?; // Make the "Identical: " part blue and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, Some(Color::Blue), false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn not_installed(&mut self, message: &str) -> Result<()> {
        // Keep the warning icon but use a distinct color for "Not installed: "
        self.print(&format!("{} ", WARNING_MARK), Some(Color::Yellow), false)?;
        
        // Split the message into parts: "Not installed: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Cyan), true)?; // Make the "Not installed: " part cyan and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn installed(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with purple text for "Installed to local: "
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Installed to local: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Magenta), true)?; // Make the "Installed to local: " part magenta and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn synced(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with green text for "Synced to repo: "
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Synced to repo: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Green), true)?; // Make the "Synced to repo: " part green and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn tracking(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with blue text for "Added to tracking: "
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Added to tracking: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Blue), true)?; // Make the "Added to tracking: " part blue and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn validation(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with cyan text for validation messages
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Always make validation messages bold
        self.print(message, Some(Color::Cyan), true)?;
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn action(&mut self, message: &str) -> Result<()> {
        // Use cyan color for actions that modify the filesystem
        self.print("+ ", Some(Color::Cyan), false)?;
        
        // Split the message into parts if it contains ": "
        if let Some(idx) = message.find(": ") {
            let (action, content) = message.split_at(idx + 2);
            self.print(action, Some(Color::Cyan), true)?;  // Make the action part cyan and bold
            self.print(content, None, false)?;
        } else {
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn header(&mut self, message: &str) -> Result<()> {
        self.print(message, None, true)?;
        writeln!(self.stdout)?;
        Ok(())
    }
    
    // Only output in verbose mode
    fn verbose(&mut self, message: &str) -> Result<()> {
        if self.verbose {
            // Special handling for example output display
            if message.starts_with("EXAMPLE:") {
                let example_content = message.trim_start_matches("EXAMPLE:");
                write!(self.stdout, "{}", example_content)?;
                return Ok(());
            }
            
            self.print(&format!("{} ", INFO_MARK), Some(Color::White), false)?;
            self.print("Verbose: ", Some(Color::White), true)?;
            self.print(message, None, false)?;
            writeln!(self.stdout)?;
        }
        Ok(())
    }
}

// Paths helper
struct Paths {
    repo_dir: PathBuf,
    config_dir: PathBuf,
    distribution_file: PathBuf,
    dotignore_file: PathBuf,
}

impl Paths {
    fn new() -> Result<Self> {
        let home = home_dir().ok_or_else(|| DotfilesError::RepoNotFound("Home directory not found".to_string()))?;
        
        let repo_dir = home.join("repos").join("dotfiles");
        let config_dir = home.join(".config");
        let distribution_file = repo_dir.join("distribution.toml");
        let dotignore_file = repo_dir.join(".dotignore");
        
        Ok(Self {
            repo_dir,
            config_dir,
            distribution_file,
            dotignore_file,
        })
    }
    
    fn repo_config_dir(&self, section: &str) -> PathBuf {
        self.repo_dir.join("config").join(section)
    }
    
    fn config_section_dir(&self, section: &str) -> PathBuf {
        self.config_dir.join(section)
    }
    
    fn repo_file_path(&self, section: &str, file: &str) -> PathBuf {
        self.repo_config_dir(section).join(file)
    }
    
    fn config_file_path(&self, section: &str, file: &str) -> PathBuf {
        self.config_section_dir(section).join(file)
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct Distribution {
    #[serde(flatten)]
    sections: HashMap<String, Section>,
}

#[derive(Debug, Serialize, Deserialize)]
struct Section {
    #[serde(default)]
    files: Vec<String>,
}

// DistributionParser
// DotfilesArchive provides access to the embedded files
struct DotfilesArchive;

impl DotfilesArchive {
    // Check if a file exists in the archive
    fn file_exists(section: &str, file: &str) -> bool {
        let path = format!("config/{}/{}", section, file);
        EMBEDDED_FILES.get(&path).is_some()
    }
    
    // Get a file from the archive
    fn get_file(section: &str, file: &str) -> Result<Vec<u8>> {
        let path = format!("config/{}/{}", section, file);
        let content = EMBEDDED_FILES.get(&path)
            .ok_or_else(|| DotfilesError::ArchiveFileNotFound(path.clone()))?;
            
        Ok(content.to_vec())
    }
    
    // Get the embedded distribution.toml
    fn get_distribution() -> Result<String> {
        let content = EMBEDDED_FILES.get("distribution.toml")
            .ok_or_else(|| DotfilesError::ArchiveFileNotFound("distribution.toml".to_string()))?;
            
        String::from_utf8(content.to_vec())
            .map_err(|e| DotfilesError::ArchiveReadError(e.to_string()).into())
    }
    
    // Get the embedded .dotignore
    fn get_dotignore() -> Result<String> {
        let content = EMBEDDED_FILES.get(".dotignore")
            .ok_or_else(|| DotfilesError::ArchiveFileNotFound(".dotignore".to_string()))?;
            
        String::from_utf8(content.to_vec())
            .map_err(|e| DotfilesError::ArchiveReadError(e.to_string()).into())
    }
}

enum DistributionSource {
    File(PathBuf),
    Embedded,
}

struct DistributionParser {
    source: DistributionSource,
}

impl DistributionParser {
    fn new(path: PathBuf) -> Self {
        Self { source: DistributionSource::File(path) }
    }
    
    fn from_embedded() -> Self {
        Self { source: DistributionSource::Embedded }
    }
    
    fn read_distribution(&self) -> Result<Distribution> {
        let content = match &self.source {
            DistributionSource::File(path) => fs::read_to_string(path)
                .context("Failed to read distribution file")?,
            DistributionSource::Embedded => DotfilesArchive::get_distribution()?,
        };
        
        let distribution: Distribution = toml::from_str(&content)
            .map_err(|e| DotfilesError::DistributionParseError(e.to_string()))?;
        
        Ok(distribution)
    }
    
    fn get_tools(&self) -> Result<Vec<String>> {
        let distribution = self.read_distribution()?;
        Ok(distribution.sections.keys().cloned().collect())
    }
    
    fn get_files(&self, tool: &str) -> Result<Vec<String>> {
        let distribution = self.read_distribution()?;
        
        match distribution.sections.get(tool) {
            Some(section_data) => Ok(section_data.files.clone()),
            None => Ok(Vec::new()),
        }
    }
    
    fn add_file(&self, tool: &str, file: &str) -> Result<()> {
        let mut distribution = self.read_distribution().unwrap_or_else(|_| Distribution {
            sections: HashMap::new(),
        });
        
        // Create tool section if it doesn't exist
        let section_entry = distribution.sections.entry(tool.to_string())
            .or_insert_with(|| Section { files: Vec::new() });
        
        // Add file if it doesn't already exist
        if !section_entry.files.contains(&file.to_string()) {
            section_entry.files.push(file.to_string());
        }
        
        // Write back to file
        let toml_content = toml::to_string(&distribution)
            .map_err(|e| DotfilesError::DistributionParseError(format!("Failed to serialize: {}", e)))?;
        
        match &self.source {
            DistributionSource::File(path) => fs::write(path, toml_content)?,
            DistributionSource::Embedded => return Err(DotfilesError::InvalidCommand(
                "Cannot modify distribution file in embedded mode".to_string()).into()),
        }
        
        Ok(())
    }
    
    fn remove_file(&self, tool: &str, file: &str) -> Result<()> {
        let mut distribution = self.read_distribution()?;
        
        // Check if tool section exists
        if let Some(section_data) = distribution.sections.get_mut(tool) {
            // Remove file if it exists
            section_data.files.retain(|f| f != file);
            
            // Write back to file
            let toml_content = toml::to_string(&distribution)
                .map_err(|e| DotfilesError::DistributionParseError(format!("Failed to serialize: {}", e)))?;
            
            match &self.source {
                DistributionSource::File(path) => fs::write(path, toml_content)?,
                DistributionSource::Embedded => return Err(DotfilesError::InvalidCommand(
                    "Cannot modify distribution file in embedded mode".to_string()).into()),
            }
            
            Ok(())
        } else {
            Err(DotfilesError::InvalidCommand(format!("Tool '{}' not found", tool)).into())
        }
    }
}

// DotIgnore parser
enum DotIgnoreSource {
    File(PathBuf),
    Embedded,
}

struct DotIgnore {
    patterns: Vec<Pattern>,
}

impl DotIgnore {
    fn new(path: &Path) -> Result<Self> {
        Self::from_source(DotIgnoreSource::File(path.to_path_buf()))
    }
    
    fn from_embedded() -> Result<Self> {
        Self::from_source(DotIgnoreSource::Embedded)
    }
    
    fn from_source(source: DotIgnoreSource) -> Result<Self> {
        let mut patterns = Vec::new();
        
        let content = match source {
            DotIgnoreSource::File(path) => {
                if path.exists() {
                    fs::read_to_string(&path)?
                } else {
                    Self::default_content().to_string()
                }
            },
            DotIgnoreSource::Embedded => {
                DotfilesArchive::get_dotignore().unwrap_or_else(|_| Self::default_content().to_string())
            }
        };
        
        for line in content.lines() {
            let line = line.trim();
            if !line.is_empty() && !line.starts_with('#') {
                patterns.push(Pattern::new(line)?);
            }
        }
        
        Ok(Self { patterns })
    }
    
    fn default_content() -> &'static str {
        r#"# Add files to ignore when syncing
# Each line is a glob pattern matched against the basename of files
*history
*_history
*id_rsa*
*authorized_keys*
*known_hosts*
*htop
*netrc
*oauth*
*robrc
*token*
*.cert
*.key
*.pem
*.crt
*credentials*
*client_secret*
"#
    }
    
    fn create_default(path: &Path) -> Result<()> {
        if !path.exists() {
            let mut file = File::create(path)?;
            file.write_all(Self::default_content().as_bytes())?;
        }
        
        Ok(())
    }
    
    fn is_ignored(&self, filename: &str) -> bool {
        let basename = Path::new(filename).file_name()
            .and_then(|os_str| os_str.to_str())
            .unwrap_or("");
            
        self.patterns.iter().any(|pattern| pattern.matches(basename))
    }
}

enum FileSource {
    Filesystem,
    Embedded,
}

// FileManager handles file operations
struct FileManager<'a> {
    paths: &'a Paths,
    formatter: &'a mut Formatter,
    dotignore: &'a DotIgnore,
    source: FileSource,
    show_all: bool,
}

impl<'a> FileManager<'a> {
    fn new(paths: &'a Paths, formatter: &'a mut Formatter, dotignore: &'a DotIgnore, show_all: bool) -> Self {
        Self {
            paths,
            formatter,
            dotignore,
            source: FileSource::Filesystem,
            show_all,
        }
    }
    
    fn from_embedded(paths: &'a Paths, formatter: &'a mut Formatter, dotignore: &'a DotIgnore, show_all: bool) -> Self {
        Self {
            paths,
            formatter,
            dotignore,
            source: FileSource::Embedded,
            show_all,
        }
    }
    
    fn install_file(&mut self, section: &str, file: &str) -> Result<()> {
        let config_file = self.paths.config_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        self.formatter.verbose(&format!("Processing file: {}", display_path))?;
        self.formatter.verbose(&format!("Target path: {}", config_file.display()))?;
        
        if self.dotignore.is_ignored(file) {
            self.formatter.verbose(&format!("File matched dotignore pattern"))?;
            self.formatter.warning(&format!("Ignored by .dotignore: {}", display_path))?;
            return Ok(());
        }
        
        let file_exists = match self.source {
            FileSource::Filesystem => {
                let repo_file = self.paths.repo_file_path(section, file);
                self.formatter.verbose(&format!("Checking source file: {}", repo_file.display()))?;
                repo_file.exists()
            },
            FileSource::Embedded => {
                self.formatter.verbose(&format!("Checking embedded file: config/{}/{}", section, file))?;
                DotfilesArchive::file_exists(section, file)
            },
        };
        
        if file_exists {
            if let Some(parent) = config_file.parent() {
                self.formatter.verbose(&format!("Creating parent directory: {}", parent.display()))?;
                create_dir_all(parent)?;
            }
            
            match self.source {
                FileSource::Filesystem => {
                    let repo_file = self.paths.repo_file_path(section, file);
                    self.formatter.verbose(&format!("Copying from: {} to: {}", repo_file.display(), config_file.display()))?;
                    fs::copy(&repo_file, &config_file)?;
                },
                FileSource::Embedded => {
                    self.formatter.verbose(&format!("Extracting embedded file to: {}", config_file.display()))?;
                    let content = DotfilesArchive::get_file(section, file)?;
                    fs::write(&config_file, content)?;
                },
            }
            
            self.formatter.installed(&format!("Installed to local: {}", display_path))?;
        } else {
            self.formatter.verbose(&format!("Source file does not exist"))?;
            self.formatter.warning(&format!("File not found: {}", display_path))?;
        }
        
        Ok(())
    }
    
    fn sync_file(&mut self, section: &str, file: &str) -> Result<()> {
        let repo_file = self.paths.repo_file_path(section, file);
        let config_file = self.paths.config_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        self.formatter.verbose(&format!("Processing file for sync: {}", display_path))?;
        self.formatter.verbose(&format!("Local path: {}", config_file.display()))?;
        self.formatter.verbose(&format!("Repo path: {}", repo_file.display()))?;
        
        if self.dotignore.is_ignored(file) {
            self.formatter.verbose(&format!("File matched dotignore pattern"))?;
            self.formatter.warning(&format!("Ignored by .dotignore: {}", display_path))?;
            return Ok(());
        }
        
        if config_file.exists() {
            self.formatter.verbose(&format!("Local file exists, proceeding with sync"))?;
            
            if let Some(parent) = repo_file.parent() {
                self.formatter.verbose(&format!("Creating repo parent directory: {}", parent.display()))?;
                create_dir_all(parent)?;
            }
            
            self.formatter.verbose(&format!("Copying from local: {} to repo: {}", config_file.display(), repo_file.display()))?;
            fs::copy(&config_file, &repo_file)?;
            self.formatter.synced(&format!("Synced to repo: {}", display_path))?;
        } else {
            self.formatter.verbose(&format!("Local file does not exist, cannot sync"))?;
            self.formatter.warning(&format!("Local file not found: {}", display_path))?;
        }
        
        Ok(())
    }
    
    fn check_status(&mut self, section: &str, file: &str) -> Result<()> {
        let config_file = self.paths.config_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        self.formatter.verbose(&format!("Checking status of file: {}", display_path))?;
        self.formatter.verbose(&format!("Local path: {}", config_file.display()))?;
        
        if self.dotignore.is_ignored(file) {
            self.formatter.verbose(&format!("File matched dotignore pattern"))?;
            self.formatter.warning(&format!("Ignored by .dotignore: {}", display_path))?;
            return Ok(());
        }
        
        let file_exists = match self.source {
            FileSource::Filesystem => {
                let repo_file = self.paths.repo_file_path(section, file);
                self.formatter.verbose(&format!("Checking if file exists in repo: {}", repo_file.display()))?;
                repo_file.exists()
            },
            FileSource::Embedded => {
                self.formatter.verbose(&format!("Checking if file exists in embedded archive: config/{}/{}", section, file))?;
                DotfilesArchive::file_exists(section, file)
            },
        };
        
        if !file_exists {
            self.formatter.verbose(&format!("File does not exist in source"))?;
            self.formatter.error(&format!("Missing in source: {}", display_path))?;
            return Ok(());
        }
        
        if !config_file.exists() {
            self.formatter.verbose(&format!("File does not exist in local config"))?;
            self.formatter.not_installed(&format!("Not installed: {}", display_path))?;
            return Ok(());
        }
        
        // Compare files
        self.formatter.verbose(&format!("Both source and local files exist, comparing content"))?;
        let source_content = match self.source {
            FileSource::Filesystem => {
                let repo_file = self.paths.repo_file_path(section, file);
                self.formatter.verbose(&format!("Reading repo file: {}", repo_file.display()))?;
                fs::read(&repo_file)?
            },
            FileSource::Embedded => {
                self.formatter.verbose(&format!("Reading embedded file: config/{}/{}", section, file))?;
                DotfilesArchive::get_file(section, file)?
            },
        };
        
        self.formatter.verbose(&format!("Reading local file: {}", config_file.display()))?;
        let config_content = fs::read(&config_file)?;
        
        if source_content == config_content {
            self.formatter.verbose(&format!("Files are identical"))?;
            
            // Only show identical files if show_all is true
            if self.show_all {
                self.formatter.identical(&format!("Identical: {}", display_path))?;
            }
        } else {
            self.formatter.verbose(&format!("Files have been modified locally"))?;
            self.formatter.modified(&format!("Modified locally: {}", display_path))?;
        }
        
        Ok(())
    }
    
    fn add_file(&mut self, section: &str, file: &str) -> Result<()> {
        let source_dir = self.paths.config_section_dir(section);
        let dest_dir = self.paths.repo_config_dir(section);
        let source_file = source_dir.join(file);
        let dest_file = dest_dir.join(file);
        let display_path = format!("{}/{}", section, file);
        
        if !source_file.exists() {
            return Err(DotfilesError::FileNotFound(source_file.to_string_lossy().to_string()).into());
        }
        
        // Create destination directory if needed
        if let Some(parent) = dest_file.parent() {
            create_dir_all(parent)?;
        }
        
        // Add file to distribution.toml
        let parser = DistributionParser::new(self.paths.distribution_file.clone());
        parser.add_file(section, file)?;
        
        // Copy file to repo
        fs::copy(&source_file, &dest_file)?;
        self.formatter.tracking(&format!("Added to tracking: {}", display_path))?;
        
        Ok(())
    }
    
    fn remove_file(&mut self, section: &str, file: &str) -> Result<()> {
        let repo_file = self.paths.repo_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        // Remove file from distribution.toml
        let parser = DistributionParser::new(self.paths.distribution_file.clone());
        parser.remove_file(section, file)?;
        
        self.formatter.info(&format!("Removed from distribution file: {}", display_path))?;
        
        // Inform user to remove the file manually
        if repo_file.exists() {
            self.formatter.warning(&format!(
                "To complete removal, manually delete the file: {}",
                repo_file.display()
            ))?;
            self.formatter.print("   ", Some(Color::Cyan), false)?;
            self.formatter.print(
                &format!("rm {}", repo_file.display()),
                Some(Color::Cyan),
                false,
            )?;
            writeln!(self.formatter.stdout)?;
        }
        
        Ok(())
    }
}

#[derive(Debug)]
enum AppMode {
    // Use files from local filesystem
    FilesystemMode,
    // Use files from embedded archive
    EmbeddedMode,
}

// App is the main application
struct App {
    paths: Paths,
    formatter: Formatter,
    distribution_parser: DistributionParser,
    dotignore: DotIgnore,
    mode: AppMode,
    verbose: bool,
    show_all: bool,
}

impl App {
    fn new(verbose: bool, show_all: bool) -> Result<Self> {
        let paths = Paths::new()?;
        let formatter = Formatter::new(verbose);
        let distribution_parser = DistributionParser::new(paths.distribution_file.clone());
        let dotignore = DotIgnore::new(&paths.dotignore_file)?;
        
        Ok(Self {
            paths,
            formatter,
            distribution_parser,
            dotignore,
            mode: AppMode::FilesystemMode,
            verbose,
            show_all,
        })
    }
    
    // Create an app instance that uses the embedded files
    fn from_embedded(verbose: bool, show_all: bool) -> Result<Self> {
        let paths = Paths::new()?;
        let formatter = Formatter::new(verbose);
        let distribution_parser = DistributionParser::from_embedded();
        let dotignore = DotIgnore::from_embedded()?;
        
        Ok(Self {
            paths,
            formatter,
            distribution_parser,
            dotignore,
            mode: AppMode::EmbeddedMode,
            verbose,
            show_all,
        })
    }
    
    fn check_paths(&mut self) -> Result<()> {
        match self.mode {
            AppMode::FilesystemMode => {
                // Check repository directory
                if !self.paths.repo_dir.exists() {
                    return Err(DotfilesError::RepoNotFound(
                        self.paths.repo_dir.to_string_lossy().to_string(),
                    )
                    .into());
                }
                
                // Check distribution file
                if !self.paths.distribution_file.exists() {
                    return Err(DotfilesError::DistributionNotFound(
                        self.paths.distribution_file.to_string_lossy().to_string(),
                    )
                    .into());
                }
            },
            AppMode::EmbeddedMode => {
                // In embedded mode, we don't need to check for physical files
                // as everything should be in the embedded archive
                self.formatter.info("Using embedded archive mode")?;
            }
        }
        
        // Create config directory if it doesn't exist
        if !self.paths.config_dir.exists() {
            self.formatter.warning(&format!(
                "Config directory not found, creating: {}",
                self.paths.config_dir.display()
            ))?;
            create_dir_all(&self.paths.config_dir)?;
        }
        
        Ok(())
    }
    
    fn create_dotignore(&self) -> Result<()> {
        match self.mode {
            AppMode::FilesystemMode => {
                DotIgnore::create_default(&self.paths.dotignore_file)?;
            },
            AppMode::EmbeddedMode => {
                // In embedded mode, we don't need to create a physical dotignore file
                // as it should be in the embedded archive
            }
        }
        Ok(())
    }
    
    fn process_section(&mut self, tool: &str, action: &str) -> Result<()> {
        self.formatter.verbose(&format!("Reading distribution file for tool: {}", tool))?;
        let files = self.distribution_parser.get_files(tool)?;
        
        self.formatter.verbose(&format!("Found {} files for tool '{}'", files.len(), tool))?;
        self.formatter.info(&format!("Processing tool: {}", tool))?;
        
        let dest_dir = self.paths.config_section_dir(tool);
        self.formatter.verbose(&format!("Tool config directory: {}", dest_dir.display()))?;
        
        if !dest_dir.exists() {
            self.formatter.verbose(&format!("Config directory for '{}' does not exist", tool))?;
            
            // Only create directories for commands that should modify the filesystem
            if action == "install" || action == "sync" {
                self.formatter.verbose(&format!("Action '{}' requires directory creation", action))?;
                self.formatter.action(&format!("Creating directory: {}", dest_dir.display()))?;
                create_dir_all(&dest_dir)?;
            } else {
                self.formatter.verbose(&format!("Skipping directory creation for read-only action: {}", action))?;
            }
        } else {
            self.formatter.verbose(&format!("Config directory for '{}' already exists", tool))?;
        }
        
        self.formatter.verbose(&format!("Creating file manager for mode: {:?}", self.mode))?;
        
        for file in files {
            self.formatter.verbose(&format!("Processing file '{}' with action '{}'", file, action))?;
            
            // Create a new file manager for each file to avoid borrowing issues
            let mut file_manager = match self.mode {
                AppMode::FilesystemMode => FileManager::new(&self.paths, &mut self.formatter, &self.dotignore, self.show_all),
                AppMode::EmbeddedMode => FileManager::from_embedded(&self.paths, &mut self.formatter, &self.dotignore, self.show_all),
            };
            
            match action {
                "install" => file_manager.install_file(tool, &file)?,
                "sync" => file_manager.sync_file(tool, &file)?,
                "status" => file_manager.check_status(tool, &file)?,
                _ => {
                    self.formatter.verbose(&format!("Invalid action requested: {}", action))?;
                    return Err(DotfilesError::InvalidCommand(format!(
                        "Invalid action: {}",
                        action
                    )).into())
                }
            }
        }
        
        self.formatter.verbose(&format!("Completed processing tool: {}", tool))?;
        Ok(())
    }
    
    fn run_sync(&mut self) -> Result<()> {
        self.formatter.header("Syncing dotfiles...")?;
        self.formatter.verbose("Starting dotfiles sync operation")?;
        
        let tools = self.distribution_parser.get_tools()?;
        self.formatter.verbose(&format!("Found {} tools in distribution file", tools.len()))?;
        
        for tool in tools {
            self.process_section(&tool, "sync")?;
        }
        
        self.formatter.verbose("Sync operation completed")?;
        Ok(())
    }
    
    fn run_status(&mut self) -> Result<()> {
        self.formatter.header("Checking dotfiles status...")?;
        self.formatter.verbose("Starting dotfiles status check")?;
        
        let tools = self.distribution_parser.get_tools()?;
        self.formatter.verbose(&format!("Found {} tools in distribution file", tools.len()))?;
        
        // Add example output
        if self.verbose {
            self.formatter.verbose("Sample output for reference:")?;
            self.formatter.verbose("EXAMPLE:✓ Identical: nvim/icons.md\n✓ Identical: nvim/init.lua\n✓")?;
            self.formatter.verbose("Actual file status:")?;
        }
        
        // Calculate total files
        let mut total_files = 0;
        for tool in &tools {
            if let Ok(files) = self.distribution_parser.get_files(tool) {
                total_files += files.len();
            }
        }
        
        // Process each tool
        for tool in tools {
            self.process_section(&tool, "status")?;
        }
        
        // Show summary of files checked
        if !self.show_all {
            self.formatter.info(&format!("Status check completed: {} files checked (use --all to see identical files)", total_files))?;
        } else {
            self.formatter.info(&format!("Status check completed: {} files checked", total_files))?;
        }
        
        self.formatter.verbose("Status check completed")?;
        Ok(())
    }
    
    fn run_install(&mut self) -> Result<()> {
        self.formatter.header("Installing dotfiles...")?;
        self.formatter.verbose("Starting dotfiles installation")?;
        
        let tools = self.distribution_parser.get_tools()?;
        self.formatter.verbose(&format!("Found {} tools in distribution file", tools.len()))?;
        
        for tool in tools {
            self.process_section(&tool, "install")?;
        }
        
        self.formatter.verbose("Installation completed")?;
        Ok(())
    }
    
    fn run_add(&mut self, tool: &str, file: &str) -> Result<()> {
        self.formatter.verbose(&format!("Adding file {}/{} to tracking", tool, file))?;
        let mut file_manager = FileManager::new(&self.paths, &mut self.formatter, &self.dotignore, self.show_all);
        file_manager.add_file(tool, file)?;
        self.formatter.verbose("File added successfully")?;
        Ok(())
    }
    
    fn run_remove(&mut self, tool: &str, file: &str) -> Result<()> {
        self.formatter.verbose(&format!("Removing file {}/{} from tracking", tool, file))?;
        let mut file_manager = FileManager::new(&self.paths, &mut self.formatter, &self.dotignore, self.show_all);
        file_manager.remove_file(tool, file)?;
        self.formatter.verbose("File removed successfully")?;
        Ok(())
    }
    
    fn run_precheck(&mut self) -> Result<()> {
        self.formatter.header("Checking distribution file...")?;
        self.formatter.verbose("Starting distribution file precheck")?;
        
        // Check if distribution file exists
        self.formatter.verbose(&format!("Checking distribution file at: {}", self.paths.distribution_file.display()))?;
        self.formatter.print("Distribution file: ", Some(Color::Cyan), false)?;
        self.formatter.print(&self.paths.distribution_file.to_string_lossy(), None, false)?;
        writeln!(self.formatter.stdout)?;
        
        if !self.paths.distribution_file.exists() {
            self.formatter.verbose("Distribution file does not exist")?;
            self.formatter.error("Distribution file not found")?;
            return Err(DotfilesError::DistributionNotFound(
                self.paths.distribution_file.to_string_lossy().to_string()).into());
        }
        
        self.formatter.verbose("Distribution file exists, proceeding with checks")?;
        self.formatter.validation("Distribution file exists")?;
        
        // Check if it's valid TOML
        self.formatter.verbose("Checking TOML syntax validity")?;
        self.formatter.print("Checking TOML syntax... ", Some(Color::Cyan), false)?;
        
        let content = fs::read_to_string(&self.paths.distribution_file)?;
        self.formatter.verbose(&format!("Read {} bytes from distribution file", content.len()))?;
        
        // Try to parse the TOML content
        match toml::from_str::<Distribution>(&content) {
            Ok(_distribution) => {
                self.formatter.verbose("TOML syntax is valid")?;
                self.formatter.validation("Valid TOML syntax")?;
                
                // Show basic info
                let line_count = content.lines().count();
                self.formatter.verbose(&format!("Distribution file has {} lines", line_count))?;
                self.formatter.print("Line count: ", Some(Color::Cyan), false)?;
                self.formatter.print(&format!("{} lines", line_count), None, false)?;
                writeln!(self.formatter.stdout)?;
                
                let tools = self.distribution_parser.get_tools()?;
                let total_files = tools.iter().fold(0, |acc, tool| {
                    if let Ok(files) = self.distribution_parser.get_files(tool) {
                        acc + files.len()
                    } else {
                        acc
                    }
                });
                
                self.formatter.verbose(&format!("Found {} tools and {} files in distribution", tools.len(), total_files))?;
                self.formatter.print("Total tools: ", Some(Color::Cyan), false)?;
                self.formatter.print(&format!("{}", tools.len()), None, false)?;
                writeln!(self.formatter.stdout)?;
                
                if self.verbose {
                    self.formatter.print("Total files tracked: ", Some(Color::Cyan), false)?;
                    self.formatter.print(&format!("{}", total_files), None, false)?;
                    writeln!(self.formatter.stdout)?;
                    
                    // List all tools and file counts in verbose mode
                    for tool in &tools {
                        if let Ok(files) = self.distribution_parser.get_files(tool) {
                            self.formatter.print(&format!("  - {}: ", tool), Some(Color::White), true)?;
                            self.formatter.print(&format!("{} files", files.len()), None, false)?;
                            writeln!(self.formatter.stdout)?;
                        }
                    }
                }
                
                writeln!(self.formatter.stdout)?;
                self.formatter.verbose("Precheck completed successfully")?;
                self.formatter.validation("Precheck passed successfully")?;
            },
            Err(e) => {
                self.formatter.verbose(&format!("TOML syntax is invalid: {}", e))?;
                self.formatter.error(&format!("Invalid TOML syntax: {}", e))?;
                return Err(DotfilesError::DistributionParseError(e.to_string()).into());
            }
        }
        
        Ok(())
    }
    
    fn run(&mut self, command: &Commands) -> Result<()> {
        match command {
            Commands::Version => {
                // Print version and build information
                println!("dotfiles-rs {}", env!("CARGO_PKG_VERSION"));
                println!("Build identity: {}", env!("BUILD_IDENTITY", "unknown"));
                println!("Newest file: {}", env!("NEWEST_FILE", "unknown"));
                return Ok(());
            },
            _ => {
                // Check required paths
                self.check_paths()?;
                
                // Create dotignore if it doesn't exist
                self.create_dotignore()?;
            }
        }
        
        match command {
            Commands::Sync => self.run_sync()?,
            Commands::Status => self.run_status()?,
            Commands::Install => self.run_install()?,
            Commands::Add { tool, file } => self.run_add(tool, file)?,
            Commands::Remove { tool, file } => self.run_remove(tool, file)?,
            Commands::Precheck => self.run_precheck()?,
            Commands::Version => {}, // Already handled above
            Commands::Usage => {
                // Print help information
                println!("dotfiles-rs - Manages dotfiles between system configuration and git repository");
                println!();
                println!("Commands:");
                println!("  sync          - Sync files from $HOME/.config to $HOME/repos/dotfiles/config");
                println!("  status        - Show status of files in distribution.toml");
                println!("  install       - Install files from $HOME/repos/dotfiles/config to $HOME/.config");
                println!("  add <tool> <file> - Add a file to distribution.toml and copy to repo");
                println!("  remove <tool> <file> - Remove a file from distribution.toml");
                println!("  precheck      - Check that distribution.toml exists and has valid syntax");
                println!("  version       - Show version and build information");
                println!("  usage         - Show this help message");
                println!();
                println!("Files matching patterns in $HOME/repos/dotfiles/.dotignore will be skipped");
            }
        }
        
        Ok(())
    }
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    // Display version and build identity if no command was provided
    if cli.command.is_none() {
        println!("dotfiles-rs {}", env!("CARGO_PKG_VERSION"));
        println!("Build identity: {}", env!("BUILD_IDENTITY", "unknown"));
        println!("Newest file: {}", env!("NEWEST_FILE", "unknown"));
        if cli.verbose {
            println!("Verbose mode enabled");
        }
        return Ok(());
    }
    
    // Automatically use embedded mode if files are embedded
    let mut app = if has_embedded_files() {
        println!("Using embedded dotfiles (found {} files)", EMBEDDED_FILES.len());
        App::from_embedded(cli.verbose, cli.all)?
    } else {
        App::new(cli.verbose, cli.all)?
    };
    
    if app.verbose {
        app.formatter.verbose("Starting application in verbose mode")?;
        if app.show_all {
            app.formatter.verbose("Showing all files including identical ones")?;
        } else {
            app.formatter.verbose("Only showing modified or missing files")?;
        }
    }
    
    app.run(&cli.command.unwrap())?;
    
    Ok(())
}