use anyhow::Result;
use clap::{Parser, Subcommand};
use std::collections::HashMap;
use std::fs::{self, create_dir_all};
use std::io::Write;
use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};
use thiserror::Error;

// Import configuration module
mod config;
use config::{FilePaths, Distribution, DistributionParser, DotIgnore};

// Include the generated file with embedded content
// This is generated by build.rs
include!(concat!(env!("OUT_DIR"), "/embedded_files.rs"));

// Custom error types
#[derive(Error, Debug)]
enum DotfilesError {
    #[error("Repository not found: {0}")]
    RepoNotFound(String),
    
    #[error("Distribution file not found: {0}")]
    DistributionNotFound(String),
    
    #[error("Failed to parse distribution file: {0}")]
    DistributionParseError(String),
    
    #[error("File not found: {0}")]
    FileNotFound(String),
    
    #[error("Invalid command format: {0}")]
    InvalidCommand(String),
    
    #[error("File not found in archive: {0}")]
    ArchiveFileNotFound(String),
    
    #[error("Failed to read file from archive: {0}")]
    ArchiveReadError(String),
}

// Status symbols
const CHECK_MARK: &str = "✓";
const CROSS_MARK: &str = "✗";
const WARNING_MARK: &str = "⚠";
const INFO_MARK: &str = "ℹ";
const ARROW_MARK: &str = "→";

// The file embedding is handled by build.rs and the embedded_files.rs file

// Command line arguments
#[derive(Parser)]
#[clap(
    name = "dotfiles-rs",
    about = "Dotfiles management done right.",
    version = env!("CARGO_PKG_VERSION"),
    override_usage = "dotfiles-rs +<action> [flags]",
    help_template = "The dotfiles-rs tool is a self-contained binary used to deploy your environment configuration.\n\nUsage: dotfiles-rs +<action> [flags]\n\nActions:\n{subcommands}\n\nOptions:\n{options}\n\nBuild identity: {version}\n",
)]
struct Cli {
    /// Enable verbose output with detailed information
    #[clap(short, long, global = true)]
    verbose: bool,

    /// Show all files including identical ones when checking status
    #[clap(short, long, global = true)]
    all: bool,
    
    /// Action to run
    #[clap(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
#[command(help_template = "Manages dotfiles between system configuration directories and git repository\n\nUsage: dotfiles-rs +<action> [flags]\n\nActions:\n{subcommands}\n\nOptions:\n{options}\n")]
#[command(subcommand_help_heading = "Actions")]
enum Commands {
    #[command(name = "+sync")]
    /// Sync files from $HOME/.config to repository
    Sync,
    
    #[command(name = "+status")]
    /// Show status of files in distribution.toml
    Status,
    
    #[command(name = "+install")]
    /// Install files from repository to $HOME/.config
    Install,
    
    #[command(name = "+add")]
    /// Add a file to distribution.toml and copy to repo
    Add {
        /// The tool name (directory under .config)
        tool: String,
        
        /// The file name to add
        file: String,
    },
    
    #[command(name = "+remove")]
    /// Remove a file from distribution.toml
    Remove {
        /// The tool name (directory under .config)
        tool: String,
        
        /// The file name to remove
        file: String,
    },
    
    #[command(name = "+precheck")]
    /// Check that distribution.toml exists and has valid syntax
    Precheck,
    
    #[command(name = "+usage")]
    /// Show usage information
    Usage,
    
    #[command(name = "+version")]
    /// Show version and build information
    Version,
    
    #[command(name = "+help")]
    /// Show this help information
    Help,
}

// Output formatter helper
struct Formatter {
    stdout: StandardStream,
    verbose: bool,
}

impl Formatter {
    fn new(verbose: bool) -> Self {
        Self {
            stdout: StandardStream::stdout(ColorChoice::Auto),
            verbose,
        }
    }
    
    fn print(&mut self, message: &str, color: Option<Color>, bold_italic: bool) -> Result<()> {
        let mut color_spec = ColorSpec::new();
        if let Some(c) = color {
            color_spec.set_fg(Some(c));
        }
        color_spec.set_bold(bold_italic);
        color_spec.set_italic(bold_italic);
        
        self.stdout.set_color(&color_spec)?;
        write!(self.stdout, "{}", message)?;
        self.stdout.reset()?;
        Ok(())
    }
    
    
    // Removed unused success method
    
    fn warning(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", WARNING_MARK), Some(Color::Yellow), false)?;
        
        // Special case for "Not installed:" messages
        if message.starts_with("Not installed:") {
            // Redirect to not_installed formatter for consistent styling
            return self.not_installed(message);
        }
        
        // Special case for "File not found:" messages
        if message.starts_with("File not found:") || message.starts_with("Local file not found:") {
            if let Some(idx) = message.find(": ") {
                let (status, path) = message.split_at(idx + 2);
                self.print(status, Some(Color::Yellow), true)?; // Make the status part yellow and bold
                self.print(path, None, false)?;
            } else {
                self.print(message, None, false)?;
            }
        } else {
            // Default handling for other warnings with the part before the colon in bold
            if let Some(idx) = message.find(": ") {
                let (status, content) = message.split_at(idx + 2);
                self.print(status, Some(Color::Yellow), true)?; // Make the status part yellow and bold
                self.print(content, None, false)?;
            } else {
                self.print(message, None, false)?;
            }
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn error(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", CROSS_MARK), Some(Color::Red), false)?;
        
        // Format error messages with status text in red and bold
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Red), true)?; // Make the status part red and bold
            self.print(content, None, false)?;
        } else {
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn info(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", INFO_MARK), Some(Color::Blue), false)?;
        
        // Process tool names differently
        if message.starts_with("Processing tool:") {
            if let Some(idx) = message.find(": ") {
                let (status, tool) = message.split_at(idx + 2);
                self.print(status, Some(Color::Blue), true)?; // Make the status part blue and bold
                self.print(tool, Some(Color::White), true)?;  // Make the tool name white and bold
            } else {
                self.print(message, None, false)?;
            }
        } else {
            // Format other info messages with status text in blue and bold
            if let Some(idx) = message.find(": ") {
                let (status, content) = message.split_at(idx + 2);
                self.print(status, Some(Color::Blue), true)?; // Make the status part blue and bold
                self.print(content, None, false)?;
            } else {
                self.print(message, None, false)?;
            }
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn modified(&mut self, message: &str) -> Result<()> {
        self.print(&format!("{} ", ARROW_MARK), Some(Color::Magenta), false)?;
        
        // Format modified messages with status text in magenta and bold
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Magenta), true)?; // Make the status part magenta and bold
            self.print(content, None, false)?;
        } else {
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn identical(&mut self, message: &str) -> Result<()> {
        // Use green for icon, and make the text blue for better visibility
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Identical: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Blue), true)?; // Make the "Identical: " part blue and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, Some(Color::Blue), false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn not_installed(&mut self, message: &str) -> Result<()> {
        // Keep the warning icon but use a distinct color for "Not installed: "
        self.print(&format!("{} ", WARNING_MARK), Some(Color::Yellow), false)?;
        
        // Split the message into parts: "Not installed: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Cyan), true)?; // Make the "Not installed: " part cyan and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn installed(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with purple text for "Installed to local: "
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Installed to local: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Magenta), true)?; // Make the "Installed to local: " part magenta and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn synced(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with green text for "Synced to repo: "
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Synced to repo: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Green), true)?; // Make the "Synced to repo: " part green and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn tracking(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with blue text for "Added to tracking: "
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Split the message into parts: "Added to tracking: " and the actual path
        if let Some(idx) = message.find(": ") {
            let (status, content) = message.split_at(idx + 2);
            self.print(status, Some(Color::Blue), true)?; // Make the "Added to tracking: " part blue and bold
            self.print(content, None, false)?;
        } else {
            // Fallback if there's no ": " in the message
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn validation(&mut self, message: &str) -> Result<()> {
        // Use green checkmark with cyan text for validation messages
        self.print(&format!("{} ", CHECK_MARK), Some(Color::Green), false)?;
        
        // Always make validation messages bold
        self.print(message, Some(Color::Cyan), true)?;
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn action(&mut self, message: &str) -> Result<()> {
        // Use cyan color for actions that modify the filesystem
        self.print("+ ", Some(Color::Cyan), false)?;
        
        // Split the message into parts if it contains ": "
        if let Some(idx) = message.find(": ") {
            let (action, content) = message.split_at(idx + 2);
            self.print(action, Some(Color::Cyan), true)?;  // Make the action part cyan and bold
            self.print(content, None, false)?;
        } else {
            self.print(message, None, false)?;
        }
        
        writeln!(self.stdout)?;
        Ok(())
    }
    
    fn header(&mut self, message: &str) -> Result<()> {
        self.print(message, None, true)?;
        writeln!(self.stdout)?;
        Ok(())
    }
    
    // Only output in verbose mode
    fn verbose(&mut self, message: &str) -> Result<()> {
        if self.verbose {
            // Special handling for example output display
            if message.starts_with("EXAMPLE:") {
                let example_content = message.trim_start_matches("EXAMPLE:");
                write!(self.stdout, "{}", example_content)?;
                return Ok(());
            }
            
            self.print(&format!("{} ", INFO_MARK), Some(Color::White), false)?;
            self.print("Verbose: ", Some(Color::White), true)?;
            self.print(message, None, false)?;
            writeln!(self.stdout)?;
        }
        Ok(())
    }
}

// Paths helper is now in the config module as FilePaths

// DotfilesArchive provides access to the embedded files
struct DotfilesArchive;

impl DotfilesArchive {
    // Check if a file exists in the archive
    fn file_exists(section: &str, file: &str) -> bool {
        let path = format!("config/{}/{}", section, file);
        EMBEDDED_FILES.get(&path).is_some()
    }
    
    // Get a file from the archive
    fn get_file(section: &str, file: &str) -> Result<Vec<u8>> {
        let path = format!("config/{}/{}", section, file);
        let content = EMBEDDED_FILES.get(&path)
            .ok_or_else(|| DotfilesError::ArchiveFileNotFound(path.clone()))?;
            
        Ok(content.to_vec())
    }
    
    // Get the embedded distribution.toml
    fn get_distribution() -> Result<String> {
        let content = EMBEDDED_FILES.get("distribution.toml")
            .ok_or_else(|| DotfilesError::ArchiveFileNotFound("distribution.toml".to_string()))?;
            
        String::from_utf8(content.to_vec())
            .map_err(|e| DotfilesError::ArchiveReadError(e.to_string()).into())
    }
    
    // Get the embedded .dotignore
    fn get_dotignore() -> Result<String> {
        let content = EMBEDDED_FILES.get(".dotignore")
            .ok_or_else(|| DotfilesError::ArchiveFileNotFound(".dotignore".to_string()))?;
            
        String::from_utf8(content.to_vec())
            .map_err(|e| DotfilesError::ArchiveReadError(e.to_string()).into())
    }
}

// DotIgnore parser is now in the config module

enum FileSource {
    Filesystem,
    Embedded,
}

// FileManager handles file operations
struct FileManager<'a> {
    paths: &'a FilePaths,
    formatter: &'a mut Formatter,
    dotignore: &'a DotIgnore,
    source: FileSource,
    show_all: bool,
}

impl<'a> FileManager<'a> {
    fn new(paths: &'a FilePaths, formatter: &'a mut Formatter, dotignore: &'a DotIgnore, show_all: bool) -> Self {
        Self {
            paths,
            formatter,
            dotignore,
            source: FileSource::Filesystem,
            show_all,
        }
    }
    
    fn from_embedded(paths: &'a FilePaths, formatter: &'a mut Formatter, dotignore: &'a DotIgnore, show_all: bool) -> Self {
        Self {
            paths,
            formatter,
            dotignore,
            source: FileSource::Embedded,
            show_all,
        }
    }
    
    fn install_file(&mut self, section: &str, file: &str) -> Result<()> {
        let config_file = self.paths.config_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        self.formatter.verbose(&format!("Processing file: {}", display_path))?;
        self.formatter.verbose(&format!("Target path: {}", config_file.display()))?;
        
        if self.dotignore.is_ignored(file) {
            self.formatter.verbose(&format!("File matched dotignore pattern"))?;
            self.formatter.warning(&format!("Ignored by .dotignore: {}", display_path))?;
            return Ok(());
        }
        
        let file_exists = match self.source {
            FileSource::Filesystem => {
                let repo_file = self.paths.repo_file_path(section, file);
                self.formatter.verbose(&format!("Checking source file: {}", repo_file.display()))?;
                repo_file.exists()
            },
            FileSource::Embedded => {
                self.formatter.verbose(&format!("Checking embedded file: config/{}/{}", section, file))?;
                DotfilesArchive::file_exists(section, file)
            },
        };
        
        if file_exists {
            if let Some(parent) = config_file.parent() {
                self.formatter.verbose(&format!("Creating parent directory: {}", parent.display()))?;
                create_dir_all(parent)?;
            }
            
            match self.source {
                FileSource::Filesystem => {
                    let repo_file = self.paths.repo_file_path(section, file);
                    self.formatter.verbose(&format!("Copying from: {} to: {}", repo_file.display(), config_file.display()))?;
                    fs::copy(&repo_file, &config_file)?;
                },
                FileSource::Embedded => {
                    self.formatter.verbose(&format!("Extracting embedded file to: {}", config_file.display()))?;
                    let content = DotfilesArchive::get_file(section, file)?;
                    fs::write(&config_file, content)?;
                },
            }
            
            self.formatter.installed(&format!("Installed to local: {}", display_path))?;
        } else {
            self.formatter.verbose(&format!("Source file does not exist"))?;
            self.formatter.warning(&format!("File not found: {}", display_path))?;
        }
        
        Ok(())
    }
    
    fn sync_file(&mut self, section: &str, file: &str) -> Result<()> {
        let repo_file = self.paths.repo_file_path(section, file);
        let config_file = self.paths.config_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        self.formatter.verbose(&format!("Processing file for sync: {}", display_path))?;
        self.formatter.verbose(&format!("Local path: {}", config_file.display()))?;
        self.formatter.verbose(&format!("Repo path: {}", repo_file.display()))?;
        
        if self.dotignore.is_ignored(file) {
            self.formatter.verbose(&format!("File matched dotignore pattern"))?;
            self.formatter.warning(&format!("Ignored by .dotignore: {}", display_path))?;
            return Ok(());
        }
        
        if config_file.exists() {
            self.formatter.verbose(&format!("Local file exists, proceeding with sync"))?;
            
            if let Some(parent) = repo_file.parent() {
                self.formatter.verbose(&format!("Creating repo parent directory: {}", parent.display()))?;
                create_dir_all(parent)?;
            }
            
            self.formatter.verbose(&format!("Copying from local: {} to repo: {}", config_file.display(), repo_file.display()))?;
            fs::copy(&config_file, &repo_file)?;
            self.formatter.synced(&format!("Synced to repo: {}", display_path))?;
        } else {
            self.formatter.verbose(&format!("Local file does not exist, cannot sync"))?;
            self.formatter.warning(&format!("Local file not found: {}", display_path))?;
        }
        
        Ok(())
    }
    
    fn check_status(&mut self, section: &str, file: &str) -> Result<()> {
        let config_file = self.paths.config_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        self.formatter.verbose(&format!("Checking status of file: {}", display_path))?;
        self.formatter.verbose(&format!("Local path: {}", config_file.display()))?;
        
        if self.dotignore.is_ignored(file) {
            self.formatter.verbose(&format!("File matched dotignore pattern"))?;
            self.formatter.warning(&format!("Ignored by .dotignore: {}", display_path))?;
            return Ok(());
        }
        
        let file_exists = match self.source {
            FileSource::Filesystem => {
                let repo_file = self.paths.repo_file_path(section, file);
                self.formatter.verbose(&format!("Checking if file exists in repo: {}", repo_file.display()))?;
                repo_file.exists()
            },
            FileSource::Embedded => {
                self.formatter.verbose(&format!("Checking if file exists in embedded archive: config/{}/{}", section, file))?;
                DotfilesArchive::file_exists(section, file)
            },
        };
        
        if !file_exists {
            self.formatter.verbose(&format!("File does not exist in source"))?;
            self.formatter.error(&format!("Missing in source: {}", display_path))?;
            return Ok(());
        }
        
        if !config_file.exists() {
            self.formatter.verbose(&format!("File does not exist in local config"))?;
            self.formatter.not_installed(&format!("Not installed: {}", display_path))?;
            return Ok(());
        }
        
        // Compare files
        self.formatter.verbose(&format!("Both source and local files exist, comparing content"))?;
        let source_content = match self.source {
            FileSource::Filesystem => {
                let repo_file = self.paths.repo_file_path(section, file);
                self.formatter.verbose(&format!("Reading repo file: {}", repo_file.display()))?;
                fs::read(&repo_file)?
            },
            FileSource::Embedded => {
                self.formatter.verbose(&format!("Reading embedded file: config/{}/{}", section, file))?;
                DotfilesArchive::get_file(section, file)?
            },
        };
        
        self.formatter.verbose(&format!("Reading local file: {}", config_file.display()))?;
        let config_content = fs::read(&config_file)?;
        
        if source_content == config_content {
            self.formatter.verbose(&format!("Files are identical"))?;
            
            // Only show identical files if show_all is true
            if self.show_all {
                self.formatter.identical(&format!("Identical: {}", display_path))?;
            }
        } else {
            self.formatter.verbose(&format!("Files have been modified locally"))?;
            self.formatter.modified(&format!("Modified locally: {}", display_path))?;
        }
        
        Ok(())
    }
    
    fn add_file(&mut self, section: &str, file: &str) -> Result<()> {
        let source_dir = self.paths.config_section_dir(section);
        let dest_dir = self.paths.repo_config_dir(section);
        let source_file = source_dir.join(file);
        let dest_file = dest_dir.join(file);
        let display_path = format!("{}/{}", section, file);
        
        if !source_file.exists() {
            return Err(DotfilesError::FileNotFound(source_file.to_string_lossy().to_string()).into());
        }
        
        // Create destination directory if needed
        if let Some(parent) = dest_file.parent() {
            create_dir_all(parent)?;
        }
        
        // Add file to distribution.toml
        let parser = DistributionParser::new(self.paths.distribution_file.clone());
        parser.add_file(section, file)?;
        
        // Copy file to repo
        fs::copy(&source_file, &dest_file)?;
        self.formatter.tracking(&format!("Added to tracking: {}", display_path))?;
        
        Ok(())
    }
    
    fn remove_file(&mut self, section: &str, file: &str) -> Result<()> {
        let repo_file = self.paths.repo_file_path(section, file);
        let display_path = format!("{}/{}", section, file);
        
        // Remove file from distribution.toml
        let parser = DistributionParser::new(self.paths.distribution_file.clone());
        parser.remove_file(section, file)?;
        
        self.formatter.info(&format!("Removed from distribution file: {}", display_path))?;
        
        // Inform user to remove the file manually
        if repo_file.exists() {
            self.formatter.warning(&format!(
                "To complete removal, manually delete the file: {}",
                repo_file.display()
            ))?;
            self.formatter.print("   ", Some(Color::Cyan), false)?;
            self.formatter.print(
                &format!("rm {}", repo_file.display()),
                Some(Color::Cyan),
                false,
            )?;
            writeln!(self.formatter.stdout)?;
        }
        
        Ok(())
    }
}

#[derive(Debug)]
enum AppMode {
    // Use files from local filesystem
    FilesystemMode,
    // Use files from embedded archive
    EmbeddedMode,
}

// App is the main application
struct App {
    paths: FilePaths,
    formatter: Formatter,
    distribution_parser: DistributionParser,
    dotignore: DotIgnore,
    mode: AppMode,
    verbose: bool,
    show_all: bool,
}

impl App {
    fn new(verbose: bool, show_all: bool) -> Result<Self> {
        let paths = FilePaths::new()?;
        let formatter = Formatter::new(verbose);
        let distribution_parser = DistributionParser::new(paths.distribution_file.clone());
        let dotignore = DotIgnore::new(&paths.dotignore_file)?;
        
        Ok(Self {
            paths,
            formatter,
            distribution_parser,
            dotignore,
            mode: AppMode::FilesystemMode,
            verbose,
            show_all,
        })
    }
    
    // Create an app instance that uses the embedded files
    fn from_embedded(verbose: bool, show_all: bool) -> Result<Self> {
        let paths = FilePaths::new()?;
        let formatter = Formatter::new(verbose);
        let distribution_parser = DistributionParser::from_embedded();
        let dotignore = DotIgnore::from_embedded()?;
        
        Ok(Self {
            paths,
            formatter,
            distribution_parser,
            dotignore,
            mode: AppMode::EmbeddedMode,
            verbose,
            show_all,
        })
    }
    
    fn check_paths(&mut self) -> Result<()> {
        match self.mode {
            AppMode::FilesystemMode => {
                // Check repository directory
                if !self.paths.repo_dir.exists() {
                    return Err(DotfilesError::RepoNotFound(
                        self.paths.repo_dir.to_string_lossy().to_string(),
                    )
                    .into());
                }
                
                // Check distribution file
                if !self.paths.distribution_file.exists() {
                    return Err(DotfilesError::DistributionNotFound(
                        self.paths.distribution_file.to_string_lossy().to_string(),
                    )
                    .into());
                }
            },
            AppMode::EmbeddedMode => {
                // In embedded mode, we don't need to check for physical files
                // as everything should be in the embedded archive
                self.formatter.info("Using embedded archive mode")?;
            }
        }
        
        // Create config directory if it doesn't exist
        if !self.paths.config_dir.exists() {
            self.formatter.warning(&format!(
                "Config directory not found, creating: {}",
                self.paths.config_dir.display()
            ))?;
            create_dir_all(&self.paths.config_dir)?;
        }
        
        Ok(())
    }
    
    fn create_dotignore(&self) -> Result<()> {
        match self.mode {
            AppMode::FilesystemMode => {
                DotIgnore::create_default(&self.paths.dotignore_file)?;
            },
            AppMode::EmbeddedMode => {
                // In embedded mode, we don't need to create a physical dotignore file
                // as it should be in the embedded archive
            }
        }
        Ok(())
    }
    
    fn process_section(&mut self, tool: &str, action: &str) -> Result<()> {
        self.formatter.verbose(&format!("Reading distribution file for tool: {}", tool))?;
        let files = self.distribution_parser.get_files(tool)?;
        
        self.formatter.verbose(&format!("Found {} files for tool '{}'", files.len(), tool))?;
        self.formatter.info(&format!("Processing tool: {}", tool))?;
        
        let dest_dir = self.paths.config_section_dir(tool);
        self.formatter.verbose(&format!("Tool config directory: {}", dest_dir.display()))?;
        
        if !dest_dir.exists() {
            self.formatter.verbose(&format!("Config directory for '{}' does not exist", tool))?;
            
            // Only create directories for commands that should modify the filesystem
            if action == "install" || action == "sync" {
                self.formatter.verbose(&format!("Action '{}' requires directory creation", action))?;
                self.formatter.action(&format!("Creating directory: {}", dest_dir.display()))?;
                create_dir_all(&dest_dir)?;
            } else {
                self.formatter.verbose(&format!("Skipping directory creation for read-only action: {}", action))?;
            }
        } else {
            self.formatter.verbose(&format!("Config directory for '{}' already exists", tool))?;
        }
        
        self.formatter.verbose(&format!("Creating file manager for mode: {:?}", self.mode))?;
        
        for file in files {
            self.formatter.verbose(&format!("Processing file '{}' with action '{}'", file, action))?;
            
            // Create a new file manager for each file to avoid borrowing issues
            let mut file_manager = match self.mode {
                AppMode::FilesystemMode => FileManager::new(&self.paths, &mut self.formatter, &self.dotignore, self.show_all),
                AppMode::EmbeddedMode => FileManager::from_embedded(&self.paths, &mut self.formatter, &self.dotignore, self.show_all),
            };
            
            match action {
                "install" => file_manager.install_file(tool, &file)?,
                "sync" => file_manager.sync_file(tool, &file)?,
                "status" => file_manager.check_status(tool, &file)?,
                _ => {
                    self.formatter.verbose(&format!("Invalid action requested: {}", action))?;
                    return Err(DotfilesError::InvalidCommand(format!(
                        "Invalid action: {}",
                        action
                    )).into())
                }
            }
        }
        
        self.formatter.verbose(&format!("Completed processing tool: {}", tool))?;
        Ok(())
    }
    
    fn run_sync(&mut self) -> Result<()> {
        self.formatter.header("Syncing dotfiles...")?;
        self.formatter.verbose("Starting dotfiles sync operation")?;
        
        let tools = self.distribution_parser.get_tools()?;
        self.formatter.verbose(&format!("Found {} tools in distribution file", tools.len()))?;
        
        for tool in tools {
            self.process_section(&tool, "sync")?;
        }
        
        self.formatter.verbose("Sync operation completed")?;
        Ok(())
    }
    
    fn run_status(&mut self) -> Result<()> {
        self.formatter.header("Checking dotfiles status...")?;
        self.formatter.verbose("Starting dotfiles status check")?;
        
        let tools = self.distribution_parser.get_tools()?;
        self.formatter.verbose(&format!("Found {} tools in distribution file", tools.len()))?;
        
        // Add example output
        if self.verbose {
            self.formatter.verbose("Sample output for reference:")?;
            self.formatter.verbose("EXAMPLE:✓ Identical: nvim/icons.md\n✓ Identical: nvim/init.lua\n✓")?;
            self.formatter.verbose("Actual file status:")?;
        }
        
        // Calculate total files
        let mut total_files = 0;
        for tool in &tools {
            if let Ok(files) = self.distribution_parser.get_files(tool) {
                total_files += files.len();
            }
        }
        
        // Process each tool
        for tool in tools {
            self.process_section(&tool, "status")?;
        }
        
        // Show summary of files checked
        if !self.show_all {
            self.formatter.info(&format!("Status check completed: {} files checked (use --all to see identical files)", total_files))?;
        } else {
            self.formatter.info(&format!("Status check completed: {} files checked", total_files))?;
        }
        
        self.formatter.verbose("Status check completed")?;
        Ok(())
    }
    
    fn run_install(&mut self) -> Result<()> {
        self.formatter.header("Installing dotfiles...")?;
        self.formatter.verbose("Starting dotfiles installation")?;
        
        let tools = self.distribution_parser.get_tools()?;
        self.formatter.verbose(&format!("Found {} tools in distribution file", tools.len()))?;
        
        for tool in tools {
            self.process_section(&tool, "install")?;
        }
        
        self.formatter.verbose("Installation completed")?;
        Ok(())
    }
    
    fn run_add(&mut self, tool: &str, file: &str) -> Result<()> {
        self.formatter.verbose(&format!("Adding file {}/{} to tracking", tool, file))?;
        let mut file_manager = FileManager::new(&self.paths, &mut self.formatter, &self.dotignore, self.show_all);
        file_manager.add_file(tool, file)?;
        self.formatter.verbose("File added successfully")?;
        Ok(())
    }
    
    fn run_remove(&mut self, tool: &str, file: &str) -> Result<()> {
        self.formatter.verbose(&format!("Removing file {}/{} from tracking", tool, file))?;
        let mut file_manager = FileManager::new(&self.paths, &mut self.formatter, &self.dotignore, self.show_all);
        file_manager.remove_file(tool, file)?;
        self.formatter.verbose("File removed successfully")?;
        Ok(())
    }
    
    fn run_precheck(&mut self) -> Result<()> {
        self.formatter.header("Checking distribution file...")?;
        self.formatter.verbose("Starting distribution file precheck")?;
        
        // Check if distribution file exists
        self.formatter.verbose(&format!("Checking distribution file at: {}", self.paths.distribution_file.display()))?;
        self.formatter.print("Distribution file: ", Some(Color::Cyan), false)?;
        self.formatter.print(&self.paths.distribution_file.to_string_lossy(), None, false)?;
        writeln!(self.formatter.stdout)?;
        
        if !self.paths.distribution_file.exists() {
            self.formatter.verbose("Distribution file does not exist")?;
            self.formatter.error("Distribution file not found")?;
            return Err(DotfilesError::DistributionNotFound(
                self.paths.distribution_file.to_string_lossy().to_string()).into());
        }
        
        self.formatter.verbose("Distribution file exists, proceeding with checks")?;
        self.formatter.validation("Distribution file exists")?;
        
        // Check if it's valid TOML
        self.formatter.verbose("Checking TOML syntax validity")?;
        self.formatter.print("Checking TOML syntax... ", Some(Color::Cyan), false)?;
        
        let content = fs::read_to_string(&self.paths.distribution_file)?;
        self.formatter.verbose(&format!("Read {} bytes from distribution file", content.len()))?;
        
        // Try to parse the TOML content
        match toml::from_str::<Distribution>(&content) {
            Ok(_distribution) => {
                self.formatter.verbose("TOML syntax is valid")?;
                self.formatter.validation("Valid TOML syntax")?;
                
                // Show basic info
                let line_count = content.lines().count();
                self.formatter.verbose(&format!("Distribution file has {} lines", line_count))?;
                self.formatter.print("Line count: ", Some(Color::Cyan), false)?;
                self.formatter.print(&format!("{} lines", line_count), None, false)?;
                writeln!(self.formatter.stdout)?;
                
                let tools = self.distribution_parser.get_tools()?;
                let total_files = tools.iter().fold(0, |acc, tool| {
                    if let Ok(files) = self.distribution_parser.get_files(tool) {
                        acc + files.len()
                    } else {
                        acc
                    }
                });
                
                self.formatter.verbose(&format!("Found {} tools and {} files in distribution", tools.len(), total_files))?;
                self.formatter.print("Total tools: ", Some(Color::Cyan), false)?;
                self.formatter.print(&format!("{}", tools.len()), None, false)?;
                writeln!(self.formatter.stdout)?;
                
                if self.verbose {
                    self.formatter.print("Total files tracked: ", Some(Color::Cyan), false)?;
                    self.formatter.print(&format!("{}", total_files), None, false)?;
                    writeln!(self.formatter.stdout)?;
                    
                    // List all tools and file counts in verbose mode
                    for tool in &tools {
                        if let Ok(files) = self.distribution_parser.get_files(tool) {
                            self.formatter.print(&format!("  - {}: ", tool), Some(Color::White), true)?;
                            self.formatter.print(&format!("{} files", files.len()), None, false)?;
                            writeln!(self.formatter.stdout)?;
                        }
                    }
                }
                
                writeln!(self.formatter.stdout)?;
                self.formatter.verbose("Precheck completed successfully")?;
                self.formatter.validation("Precheck passed successfully")?;
            },
            Err(e) => {
                self.formatter.verbose(&format!("TOML syntax is invalid: {}", e))?;
                self.formatter.error(&format!("Invalid TOML syntax: {}", e))?;
                return Err(DotfilesError::DistributionParseError(e.to_string()).into());
            }
        }
        
        Ok(())
    }
    
    fn run(&mut self, command: &Commands) -> Result<()> {
        match command {
            Commands::Version => {
                // Print version and build information
                println!("dotfiles-rs {}", env!("CARGO_PKG_VERSION"));
                println!("Build identity: {}", env!("BUILD_IDENTITY", "unknown"));
                println!("Newest file: {}", env!("NEWEST_FILE", "unknown"));
                return Ok(());
            },
            Commands::Help => {
                // Reuse the Usage command for now
                return self.run_usage();
            },
            _ => {
                // Check required paths
                self.check_paths()?;
                
                // Create dotignore if it doesn't exist
                self.create_dotignore()?;
            }
        }
        
        match command {
            Commands::Sync => self.run_sync()?,
            Commands::Status => self.run_status()?,
            Commands::Install => self.run_install()?,
            Commands::Add { tool, file } => self.run_add(tool, file)?,
            Commands::Remove { tool, file } => self.run_remove(tool, file)?,
            Commands::Precheck => self.run_precheck()?,
            Commands::Version => {}, // Already handled above
            Commands::Help => {}, // Already handled above
            Commands::Usage => self.run_usage()?,
        }
        
        Ok(())
    }
    
    fn run_usage(&self) -> Result<()> {
        // Print help information
        println!("dotfiles-rs - Manages dotfiles between system configuration and git repository");
        println!();
        println!("Actions:");
        println!("  +sync                 - Sync configuration.");
        println!("  +status               - Show configuration status.");
        println!("  +install              - Install configuration.");
        println!("  +add <tool> <file>    - Add file to distribution.toml.");
        println!("  +remove <tool> <file> - Remove file from distribution.toml.");
        println!("  +precheck             - Check that distribution.toml exists and has valid syntax");
        println!("  +version              - Show version and build information.");
        println!("  +usage                - Show this help message.");
        println!("  +help                 - Show this help message.");
        println!();
        println!("Usage: dotfiles-rs +<action> [flags]");
        println!();
        println!("Options:");
        println!("  -v, --verbose  Enable verbose output with detailed information");
        println!("  -a, --all      Show all files including identical ones when checking status");
        println!();
        println!("Examples:");
        println!("  dotfiles-rs +status");
        println!("  dotfiles-rs +install");
        println!("  dotfiles-rs +add nvim init.lua");
        println!();
        println!("Files matching patterns in $HOME/repos/dotfiles/.dotignore will be skipped");
        Ok(())
    }
}

fn main() -> Result<()> {
    // Process raw arguments to check for +command style
    let args: Vec<String> = std::env::args().collect();
    
    if args.len() <= 1 {
        // No arguments - display version information
        println!("dotfiles-rs {}", env!("CARGO_PKG_VERSION"));
        println!("Build identity: {}", env!("BUILD_IDENTITY", "unknown"));
        println!("Newest file: {}", env!("NEWEST_FILE", "unknown"));
        
        // Show basic usage
        println!("\nUsage: dotfiles-rs +<action> [flags]");
        println!("\nAll actions must be prefixed with a '+', for example:");
        println!("  dotfiles-rs +status");
        println!("  dotfiles-rs +install");
        println!("  dotfiles-rs +precheck");
        println!("  dotfiles-rs +usage (for more information)");
        
        return Ok(());
    }
    
    // Handle the first command-line argument
    let first_arg = &args[1];
    
    // Check if it's a help flag
    if first_arg == "--help" || first_arg == "-h" {
        let _cli = Cli::parse(); // This will display help and exit
        return Ok(());
    }
    
    // Verify action has a + prefix
    if !first_arg.starts_with('+') || first_arg.len() <= 1 {
        eprintln!("Error: Actions must be prefixed with '+' (for example: +install)");
        eprintln!("Usage: dotfiles-rs +<action> [flags]");
        eprintln!("Run 'dotfiles-rs +usage' for a list of available actions");
        return Ok(());
    }
    
    // No need to remove the + prefix anymore
    let cmd = first_arg.to_lowercase();
    
    // Parse the action
    let command = match cmd.as_str() {
        "+sync" => Some(Commands::Sync),
        "+status" => Some(Commands::Status),
        "+install" => Some(Commands::Install),
        "+precheck" => Some(Commands::Precheck),
        "+usage" => Some(Commands::Usage),
        "+version" => Some(Commands::Version),
        "+add" => {
            if args.len() >= 4 {
                Some(Commands::Add {
                    tool: args[2].clone(),
                    file: args[3].clone(),
                })
            } else {
                eprintln!("Error: +add requires tool and file arguments");
                eprintln!("Usage: dotfiles-rs +add <tool> <file>");
                return Ok(());
            }
        },
        "+remove" => {
            if args.len() >= 4 {
                Some(Commands::Remove {
                    tool: args[2].clone(),
                    file: args[3].clone(),
                })
            } else {
                eprintln!("Error: +remove requires tool and file arguments");
                eprintln!("Usage: dotfiles-rs +remove <tool> <file>");
                return Ok(());
            }
        },
        "+help" => Some(Commands::Help),
        _ => {
            eprintln!("Unknown action: {}", cmd);
            eprintln!("Run 'dotfiles-rs +usage' for a list of available actions");
            return Ok(());
        }
    };
    
    // Get verbose and all flags
    let verbose = args.contains(&"--verbose".to_string()) || args.contains(&"-v".to_string());
    let all = args.contains(&"--all".to_string()) || args.contains(&"-a".to_string());
    
    // Create app instance
    let mut app = if has_embedded_files() {
        println!("Using embedded dotfiles (found {} files)", EMBEDDED_FILES.len());
        App::from_embedded(verbose, all)?
    } else {
        App::new(verbose, all)?
    };
    
    // Set up verbose output if needed
    if verbose {
        app.formatter.verbose("Starting application in verbose mode")?;
        if all {
            app.formatter.verbose("Showing all files including identical ones")?;
        } else {
            app.formatter.verbose("Only showing modified or missing files")?;
        }
    }
    
    if let Some(cmd) = command {
        app.run(&cmd)?;
    }
    
    Ok(())
}

